# how-to-use-makefile-with-go
Provides a simple makefile to automate build process of simple go projects
## اتوماتیک کردن کارها

من چون از دنیای زیبایِ زبانِ  C آمده‌ام (که پدر آفرینش است) عادت کرده‌ام که برای اتوماتیک کردن کارها ازAutotools و بویژه از makefileها کمک بگیرم. فرض کنید یک پروژه‌ی ساده داریم که می‌خواهیم برخی فرایندهایِ ساده‌ی کامپایل و تست آن را اتوماتیک کنیم. من برای پروژه‌های ساده‌ی زبان گو همانند تمرینات بوت کمپ از یک makefile با محتویِ زیر استفاده می‌کنم. فرض کنید که نام پروژه‌ی فرضی ما how-to-use-makefile-with-go باشد؛ آنگاه makefile من می‌تواند به شکل زیر باشد:


    project_name=how-to-use-makefile-with-go

    github=github.com/ArdeshirV
    target_ext=  # ".exe" for windows
    temporary_folder=./tmp
    tool=go
    source_ext=go
    mod_file=go.mod
    formatter=gofmt
    compiler=$(tool) build
    executer=$(tool) run
    main_file_name=main
    main_file=$(main_file_name).$(source_ext)
    target=$(project_name)  # .$(target_ext) just for windows
    target2=$(main_file_name)  # .$(target_ext) just for windows
    temp=$(temporary_folder)/$(main_file)

    $(target): $(main_file) update
      $(compiler) $(main_file)

    build: $(target) update

    run: $(main_file) update
      $(executer) $(main_file)

    init: $(main_file)
      $(tool) mod init $(github)/$(project_name)
      $(tool) mod tidy

    update: $(main_file)
      $(tool) get -u

    test: $(main_file) clean
      $(tool) test ./... -count=1 -v

    fmt: $(main_file)
      [ -e $(temporary_folder) ] && rm -fR $(temporary_folder) || echo -n
      mkdir $(temporary_folder)
      $(formatter) $(main_file) > $(temp)
      [ -e $(temp) ] && cat $(temp) > $(main_file) && rm -f $(temp) || echo -n
      [ -e $(temporary_folder) ] && rm -fR $(temporary_folder) || echo -n

    format: fmt

    clean:
      [ -e $(target2) ] && rm -f $(target2) || echo -n
      [ -e $(target) ] && rm -f $(target) || echo -n


فرض کنید در کنار فایل makefile بالا یک برنامه‌ی ساده‌ی گو هم در فایلِ main.go به شکل زیر داریم(که اینجا عمدا به شکل زشتی نوشته شده‌ است):

    package main
    import ("fmt")
    func main() {
    fmt.Printf("The Go Programming Language\n")
    }


حالا با داشتن makefile بالا و به شرط نصب بودن ابزار make و در مسیر فایل‌های اجرایی تعریف شده بودن برنامه‌های autotools که اغلب همراه با کامپایلر زبانِ مقدس C نصب می‌شوند می‌توانیم دستورات جالب زیر را وارد کنیم:

    make init
که دستورات زیرا را اجرا خواهد کرد:

    go mod init github.com/ArdeshirV/how-to-use-makefile-with-go
    go mod tidy


و یا با دستور زیر:

    make
    
    
فایل خروجی و اجرایی برنامه ساخته خواهد شد و قابل اجرا خواهد بود.
و با دستور زیر:

    make clean
    
    
تمامی فایل‌های اضافی برنامه و فایل‌های اجرایی ساخته شده را می‌توانیم حذف کنیم.
و نیز با دستور بسیار جالب:

    make fmt
    
    
سورس کد برنامه با فرمت استاندارد زبان گو بازنویسی خواهد شد و در نتیجه فایل زشتِ main.go که در بالا دیدیم با دستور بالا به شکلِ زیبایِ زیر بازسازی خواهد شد:

    package main

    import (
      "fmt"
    )

    func main() {
      fmt.Printf("The Go Programming Language\n")
    }

برای تست برنامه در صورت وجود تست فایل‌ها نیز می‌توان دستور زیر را وارد کرد:

    make test
    
    
که خودش علاوه بر پاک کردن فایل‌های غیر ضروری پروژه دستورات زیر را اجرا خواهد کرد:

    go test ./... -count=1 -v
 
 
برای دیدن یک پروژه‌ی ساده‌ی نمونه که می‌تواند الگوی کار شما باشد می‌توانید به این [رپوسیتوری](https://github.com/ArdeshirV/how-to-use-makefile-with-go/) مراجعه فرمایید:

https://github.com/ArdeshirV/how-to-use-makefile-with-go/

و شاید بهترست که همین الآن آن را کلون کنید:

    git clone https://github.com/ArdeshirV/how-to-use-makefile-with-go/


### این پروژه را تقدیم می‌کنم به استاد عزیزم [❤روزبه شریف نسب❤](https://github.com/rsharifnasab) 

#ArdeshirV

--------------------------------------------------------------------------------------

## پاسخ استاد شریف نصب و تحلیل ایشان از این پروژه

سلام به جناب اردشیر عزیز
خیلی لطف دارید به من و کلا automate کردن هم باعث خوشحالی منه و حسابی هیجان زده ام.

این کار automate کردن به نظرم من به نفس خودش، خیلی شیرینه. این makefile ها هم خیلی زیبا ان و همونطور که گفتید جاهای مختلفی استفاده میشن.

اما من به عنوان کوچیک شما اجازه بدین یه نقدی هم بکنم.
جمله‌ی اول شما رو اگه ساده کنیم یه چنین چیزی توش می‌بینم:
من چون بک گراند XXX  را دارم عادت کرده‌ام که از YYY کمک بگیرم.

اگرچه الگوی تکرار شونده‌ای است، اما من به شخصه آن را نمی‌پسندم. ما بر اساس نیاز باید از ابزار استفاده کنیم نه عادت. البته که دانش قبلی هم در انتخاب ابزار بی تاثیر نیست ولی باید دید اصلا ابزار آن جا کاربرد دارد و استفاده از این ابزار منطقی هست یا نه.

من ۳ دسته را تصور می‌کنم که یک ابزار یک کار را راه بندازد، ولی بهترین روش نباشد. مثلا همین makefile که کار کامپایل برنامه های گو را راه می‌اندازد ولی بهترین روش ممکن نیست.

با توجه به اینکه همین بحث makfile را می‌خواهم جلو ببرم سعی میکنم از همین استفاده کنم.

اولین ابزار استفاده از یک ابزار خیلی قوی برای یک کار کوچک است. مثلا تعلیم یک مدل deep learning برای تشخیص اینکه این رنگ ابی است یا قرمز. یا مثلا استفاده از یک فریمورک وب بزرگ و سنگین برای نوشتن یک بک‌اند بسیار ساده. یا در این مورد استفاده از یک makefile بزرگ برای کامپایل فقط یک برنامه‌ با یک فایل که روند کامپایل سریعی هم دارد و دستور کامپایل نیز سرراست است. در این مورد لزومی اصلا به استفاده از چیزی به جز دستورات کامپایلر نیست. 

دومین حالت استفاده از یک ابزار ضعیف برای یک کار پیچیده است. مثلا اگر پروژه‌ی بسیار بزرگی داریم مدیریت یک makefile می‌تواند طاقت فرسا باشد و برای همین ابزارهای پیشرفته تر مثلا cmake می‌توانند مناسب باشند. و یا مثلا استفاده از سی برای یک پروژه‌ی وب اگرچه می‌تواند مزیت هایی داشته باشد ولی در اکثر مواقع راه حل مناسبی نیست چون بیشتر به پیچیدگی مسئله می‌افزاید. البته اینجا توهین به سی نباشه =)

سومین حالت که به نظرم اینجا مصداق داره اینه که از ابزار به نحوی استفاده کنیم که اصلا مدنظر نبوده و مزیت رقابتی اون ابزار به نوعی محو بشه. پس اینجا ما می‌مونیم و یک ابزار که مزایاش رو نداریم ولی معایبش رو باید تحمل کنیم. 
شاید بپرسید مزیت make file چیه اصلا که اینجا از دست رفته؟ من یه جمله‌ی سرراست پیدا کردم که اینجا قرار میدم:
Makefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make.

منبع: 
https://makefiletutorial.com/

این موضوعی که اینجا اشاره شد اتفاقا توی ساختار makfile هم خیلی به چشم می‌خوره و ما بهتره که بشناسیم ساختار و هدفش رو و درست استفاده کنیم تا اینکه بخوایم به زور خمش کنیم تا به چیزی که ما میخوایم برسه. البته این رو کلی گفتم. 

هدف makefile اینه که در یک پروژه‌ی چند فایلی، ما براش وابستگی ها رو تصریح کنیم و بعد براساس اینکه چه فایلی تغییر کرده، خود اون فایل و چیزایی که به اون وابسته هستند رو مجددا کامپایل کنه و از کامپایل مجدد فایل هایی که تغییری نکردن یا وابستگی هاشون تغیری نکرده پرهیز کنه. چرا؟ برای کاهش زمان کامپایل مجدد. چون همونطور که مشخصه کامپایل اول اصلا این ها براش معنی نداره و همه چیز باید کامپایل بشه نهایتا ترتیب کامپایل مهم میشه. 
حالا ما توی makefile یکسری target داریم که میشه چیزی که نهایتا قراره ساخته بشه و براش نیازه که یکسری کار انجام بشه و اونا میشن پیشنهاد اون target، ولی اگر توی makefile بحث پیشنیازی رو نخوایم داشته باشیم با یک سوییچ کیس توی bash script فرق خاصی نخواهد داشت، پس اینطوریه که این ابزار رو ما استفاده کردیم ولی مزیتی برامون نداشت، بلکه یه اسکریپت ساده‌ی bash هم پرتابل تر بود هم احتمالا سریع تر و بدون اشکال تر. اگر دوست داشتید اون رو هم با هم می‌تونیم بنویسیم.
